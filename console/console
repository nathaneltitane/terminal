#!/bin/bash

# dependencies #

# script #

# version #

# variables #

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults #

# terminal

if [ -z "$(command -v tput)" ]
then
	# ansi colors
	
	if [[ -t 1 ]]
	then
		black=$(echo -e \\e\[30m)
		red=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		yellow=$(echo -e \\e\[33m)
		blue=$(echo -e \\e\[34m)
		magenta=$(echo -e \\e\[35m)
		cyan=$(echo -e \\e\[36m)
		white=$(echo -e \\e\[97m)
		reset=$(echo -e \\e\[39m)
	fi
else
	# colors and attributes
	
	if [[ -t 1 ]]
	then
		black=$(tput setaf 0)
		red=$(tput setaf 1)
		green=$(tput setaf 2)
		yellow=$(tput setaf 3)
		blue=$(tput setaf 4)
		magenta=$(tput setaf 5)
		cyan=$(tput setaf 6)
		white=$(tput setaf 7)

		bold=$(tput bold)
		underline_start=$(tput smul)
		underline_stop=$(tput rmul)
		reverse=$(tput rev)
		blink=$(tput blink)
		invisible=$(tput invis)
		standout_start=$(tput smso)
		standout_stop=$(tput rmso)
		
		reset=$(tput sgr 0)														# reset all attributes
		
		# terminal control
		
		terminal_info=$(tput longname)											# full description of terminal
		
		terminal_height=$(tput lines)											# number of lines in terminal
		terminal_width=$(tput cols)												# number of columns in terminal
		terminal_colors=$(tput colors)											# number of colors available
		
		terminal_save_cursor=$(tput sc)											# save cursor position of terminal
		terminal_restore_cursor=$(tput rc)										# restore cursor position of terminal
		
		terminal_home_cursor=$(tput home)										# move cursor to upper left corner (0,0) Same as 'tput cup 0 0'
		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})				# move cursor to position (row, column)
		terminal_cursor_down=$(tput cud1)										# move cursor down 1 line
		terminal_cursor_up=$(tput cuu1)											# move cursor up 1 line
		
		terminal_cursor_hide=$(tput civis)										# set cursor to invisible state
		terminal_cursor_show=$(tput cnorm)										# set cursor to normal state
		
		terminal_save_screen=$(tput smcup)										# save screen contents
		terminal_restore_screen=$(tput rmcup)									# restore screen contents
		
		terminal_clear_right=$(tput el)											# clear from cursor to end of line - left
		terminal_clear_left=$(tput el)											# clear from cursor to beginning of line - right
		terminal_clear_down=$(tput ed)											# clear from cursor to end of the screen - down
		terminal_clear_all=$(tput clear)										# clear entire screen and home cursor (0,0) - all
	fi
fi

# markers

marker_top='[ ⋀ ]'
marker_bot='[ ⋁ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ ± ]'
marker_msg='[ ¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ • ]'

marker_yes='[ ✓ ]'
marker_not='[ ⨉ ]'

marker_nul='     '

# prompt

console.prompt () {
	# initialize string return array
	
	console_str=()

	begin="${1}"
	end="${2}"
	
	[ -z "${count}" ] && count="80"
	

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	[ $# -ge 0 ] && span_character="/"											# 0 argument   - full dash line
	[ $# -eq 1 ] && span_character=" "											# 1 argument   - pad end of line with space
	[ $# -eq 3 ] && span_character="${3}"										# 3 arguments  - replace span character with argument 3
	
	[ $# -ge 2 ] && span=${span::-6}											# 2+ arguments - reduce span by 6 characters: compensate for line marker + space
	[ $# -ge 2 ] && begin="${begin} "											# 2+ arguments - append space to beginning value
	[ $# -ge 2 ] && end=" ${end}"												# 2+ arguments - prepend space to end value
	
	# fold paragraph if character count is above 80
	# indent second line onward (6 spaces) to match line marker
	
	if [ $# -eq 1 ] && [ "${#begin}" -ge "${count}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${count}" | sed -e '2,$s/^/      /g')
	fi
	
	# substitute span character
	
	span="${span//-/$span_character}"
	
	# print first argument
	
	span_begin=$(echo -ne "${begin}")
	
	# print other arguments as fixed width prompt if present
	
	# calculate span width - remove 6 characters for prompt header
	
	span_count=$(( ${#span} - ${#begin} - ${#end} ))
	
	# set new padding width
	
	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	span_middle="${span}"
	
	span_end=$(echo -e "${end}")
	
	# populate array at end to avoid integrating spaces
	
	console_str+=("${span_begin}""${span_middle}""${span_end}")
}

# highlights

console.red () {
	console.prompt "$@"
	value="${console_str[@]}"
	
	echo -e "${red}${value}${reset}"
}

console.green () {
	console.prompt "$@"
	value="${console_str[@]}"
	
	echo -e "${green}${value}${reset}"
}

console.yellow () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${yellow}${value}${reset}"
}

console.blue () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${blue}${value}${reset}"
}

console.magenta () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${value}${reset}"
}

console.cyan () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${value}${reset}"
}

# prompts #

console.maru () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${green}${marker_maru} ${value}${reset}"
}

console.batsu () {
	value="${console_str[@]}"
	console.prompt "$@"

	echo -e "${red}${marker_batsu} ${value}${reset}"
}

console.bako () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_bako} ${value}${reset}"
}

console.sankaku () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${marker_sankaku} ${value}${reset}"
}

console.inf() {
	console.prompt "${@}"
	value="${console_str[@]}"

	echo -e "${blue}${marker_inf} ${value}${reset}"
}

console.msg () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${marker_msg} ${value}${reset}"
}

console.wrn () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${yellow}${marker_wrn} ${value}${reset}"
}

console.add () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${blue}${marker_add} ${value}${reset}"
}

console.rem () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${red}${marker_rem} ${value}${reset}"
}

console.fwd () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_fwd} ${value}${reset}"
}

console.rev () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_rev} ${value}${reset}"
}

console.stp () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_stp} ${value}${reset}"
}

console.dwl () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"
}

console.upl () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_top} ${value}${reset}"
}

console.scs () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"
}

console.err () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"
}

console.ins () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_ipt} ${value}${reset}"
}

# prompt inputs

# no new line after prompt: keeps user input beside prompt
# includes space after value to separate input
# use for questions, input, user values

console.ask () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_ask} ${value} ${reset}"
}

console.ipt () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_add} ${value} ${reset}"
}

console.usr () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_usr} ${value} ${reset}"
}

# numbering

# use to mark directives or instructions

console.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	console.prompt "$@"
	value="${console_str[@]}"
	
	echo -e "${before}${number}${after} ${value}"
}

# prompt separator

# no marker
# use to separate notices and messages from execution blocks

console.sep () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${value}"
}

# separate

# predefined separator:
# use to separate instructions or warnings from prompts

console.separate () {

	console.sep
	echo
}

# prompt script title

# generic title from script name

console.script () {
	description="${1}"

	console.msg "${description}" "[ ${script%-*} // ${version} ]"
}

# wait

console.wait () {
	# wait in seconds
	
	seconds="${1}"
	
	# set defaults
	
	[ -z "${seconds}" ] && seconds="1"

	sleep "${seconds}"
}

# countdown

console.countdown () {
	before="[ "
	after=" ]"
	
	seconds="$1"
	
	shift
	
	console.prompt "$@"
	value="${console_str[@]}"
	
	shift
	
	while [ "${seconds}" -ge 0 ]
	do
		echo -ne "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"
		
		sleep 1
	done
	
	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# spinner

console.progress () {
	# catch PID of last command

	PID=$!

	spinner="\/"
	before="[ "
	after="]"

	console.prompt "$@"
	value="${console_str[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -ne "\r${before} \b${spinner:i++%${#spinner}:1} ${after} ${value}\c "

		sleep 0.175
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# directory

console.directory () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		directory="${2}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		console.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		[ ! -d "${path}"/"${directory}" ] && mkdir -p "${path}"/"${directory}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# directory

console.file () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	for file in ${list[@]}
	do
		console.add "Creating file" "[ ${file} ]"
		echo

		# create file and set permissions

		[ ! -f "${path}"/"${file}" ] && touch "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${fi}"
	done

	# unset array

	list=()
}

# delete

console.delete () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	for directory in ${list[@]}
	do
		console.add "Deleting" "[ ${file} ]"
		echo

		# remove file

		[ -f "${path}"/"${file}" ] && rm -rf "${path}"/"${file}"
	done

	# unset array

	list=()
}

# get

console.get () {
	curl -sL "${source}/${file}" > "${path}"/"${file}" &

	console.progress "Downloading" "[ ${file} ]"
	echo

	chmod a+rx "${path}"/"${file}"
}

# download

console.download () {
	source="${1}"
	path="${2}"

	# "${3}" - array - file list

	list=(${@:3}) 

	console.dwl "Loading..."
	echo

	if [ -z "${list}" ]
	then
		source="${1}"
		path="${2}"

		# "${3}" - variable - file

		file="${3}"

		console.get

	else
		for file in ${list[@]}
		do
			console.get
		done

		# unset array

		list=()
	fi
}

# put

console.put () {
	type="${1}"

	curl \
		-X POST "${destination}/${file}"	\
		-H "Content-Type: ${type}"			\
		-d "${file}" & 

	console.progress "Uploading" "[ ${file} ]"
	echo
}

# upload

console.upload () {

	console.upl "Loading..."
	echo

	console.put

}

# silence

console.silence () {
	# wrap command execution and redirect all output to null sink:
	# provides fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> /dev/null 2>&1
}

# log

console.log () {
	# wrap command execution and redirect all output to /var log file:
	# provides logged and fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> "${PREFIX}"/var/log/"${script}"-"${stamp}".log 2>&1
}

# password

console.password () {
	#obfuscate password input with custom mask

	mask_character="•"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"
}

# input

console.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		console.ipt "${prompt}"

		[[ "${value}" = *password* ]] && console.password || read input

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				console.err "${prompt%:} cannot be empty."
				echo
				
				prompt="$(echo ${label} | sed 's/_/ /'):"

				console.ipt "${prompt}"

				[[ "${value}" = *password* ]] && console.password || read input
			else
					break
			fi
		done

		value=${label,}

		console_rtn+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean

console.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"
	
	console.log "${command_autoremove}" &
	
	console.progress "Flushing packages..."
	echo
	
	console.log "${command_clean}" &

	console.progress "Cleaning..."
	echo
}

# hold

console.hold () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_hold="apt-mark hold"

	console.inf "Holding packages."
	echo

	for package in ${list[@]}
	do
		console.wrn "Holding" "[ '${package}' ]"
		echo

		console.log "${command_hold} ${package}" &

		console.progress "Holding..."
		echo
	done
}

# release

console.release () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_unhold="apt-mark unhold"

	console.inf "Releasing packages."
	echo

	for package in ${list[@]}
	do
		console.wrn "Releasing" "[ '${package}' ]"
		echo

		console.log "${command_unhold} ${package}" &

		console.progress "Releasing..."
		echo
	done
}

# reconfigure

console.reconfigure () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi
	
	console.inf "Reconfiguring packages."
	echo

	for directory in ${list[@]}
	do
		console.wrn "Reconfiguring" "[ '${package}' ]"
		echo

		[ $(dpkg -l | grep -i "${package}") ] && sudo dpkg-reconfigure "${package}"
	done
}

# install

console.install () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	# use '--no-install-recommends' option to keep bloat to a minimum

	command_install="apt-get install --no-install-recommends --no-upgrade"

	console.inf "Installing packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -o installed)" ]
		then
			console.wrn "Package not installed" "[ '${package}' ]"
			echo

			console.log "yes | ${command_install} ${package}" &

			console.progress "Installing..."
			echo
		else
			console.scs "Package installed" "[ '${package}' ]"
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# cleanup

	console.clean
}

# update

console.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	console.inf "Processing package and repository information."
	echo

	console.log "${command_update}" &

	console.progress "Updating..."
	echo
}

# upgrade

console.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get upgrade"

	console.inf "Processing installed packages."
	echo

	console.log "yes | ${command_upgrade}" &

	console.progress "Upgrading..."
	echo
}

# purge

console.purge () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_purge="sudo apt-get purge"

	console.inf "Purging selected packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -o installed)" ]
		then
			console.wrn "Selected package" "[ '${package}' ]"
			echo

			console.log "yes | ${command_purge} ${package}" &

			console.progress "Purging..."
			echo
		else
			console.scs "Package not installed" "[ '${package}' ]"
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done
	
	# cleanup
	
	console.clean
}

# dialog

console.dialog () {

	# dialog window title

	title="${script%.sh} - ${1}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${@}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${@}"
	}

	# define dialog usage

	if [[ -z $(command -v zenity) ]]
	then
		dialog=$(k_dialog)

	elif [[ -z $(command -v kdialog) ]]
	then
		dialog=$(g_dialog)
	else
		console.wrn "'dialog' not installed."
		console.wrn "This utility must be run using the 'directory' option."
		echo

		console.fwd "Exiting..."
		echo

		exit 1
	fi
}

console.clear () {
	console.wait

	clear
}

console.exit () {
	instance="${1}"

	console.countdown 3 "Exiting" "[ ${instance} ]"

	kill -9 $(pgrep -f "${SHELL}")
}

console.kill () {
	process_name="${1}"

	[ -x $(command -v pgrep) ]   && process_id=$(pgrep -f "${process_name}")
	[ -x $(command -v ps) ]      &&  process_id=$(ps -A | grep "${process_name}" | cut -d ' ' -f 1)

	[ -x $(command -v kill) ]    && kill_command=$(kill -9 ${process_id})
	[ -x $(command -v pkill) ]   && kill_command=$(pkill ${process_name})

	"${kill_command}"
}

console.trap.clean () {
	checkpoint="${1}"
	instance="${2}"

	if [ -f "${BINARIES_DIRECTORY}"/${checkpoint} ]
	then
		console.scs "Setup complete" "[ ${instance} ]"
		echo

		console.fwd "Removing setup files..."
		echo

		remove_list=(
			"${instance}"
		)

		console.delete ${remove_list[@]}

		sed -i					\
			-e '/.*email/d'		\
			-e '/.*password/d'	"${BINARIES_DIRECTORY}"/"${instance}"
	else
		console.err "Setup errors were encountered" "[ ${instance} ]"
		echo
		
		console.inf "Consult setup logs for details." '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

console.trap () {
	instance="${1}"
	
	[ $# -eq 1 ] && signal="EXIT" || signal="${2}"

	trap "${instance}" "${signal}"
}

console.user () {
	console.inf "Current user name is ${SUDO_USER:-$USER}."

	sleep 1
}