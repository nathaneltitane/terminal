#!/bin/bash

# dependencies #

# script #

# version #

# variables #

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults #

# terminal

if [ -z "$(command -v tput)" ]
then
	# ansi colors

	if [[ -t 1 ]]
	then
		black=$(echo -e \\e\[30m)
		red=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		yellow=$(echo -e \\e\[33m)
		blue=$(echo -e \\e\[34m)
		magenta=$(echo -e \\e\[35m)
		cyan=$(echo -e \\e\[36m)
		white=$(echo -e \\e\[97m)
		reset=$(echo -e \\e\[39m)
	fi
else
	# colors and attributes

	if [[ -t 1 ]]
	then
		black=$(tput setaf 0)
		red=$(tput setaf 1)
		green=$(tput setaf 2)
		yellow=$(tput setaf 3)
		blue=$(tput setaf 4)
		magenta=$(tput setaf 5)
		cyan=$(tput setaf 6)
		white=$(tput setaf 7)

		bold=$(tput bold)
		underline_start=$(tput smul)
		underline_stop=$(tput rmul)
		reverse=$(tput rev)
		blink=$(tput blink)
		invisible=$(tput invis)
		standout_start=$(tput smso)
		standout_stop=$(tput rmso)

		reset=$(tput sgr 0)														# reset all attributes

		# terminal control

		terminal_info=$(tput longname)											# full description of terminal

		terminal_height=$(tput lines)											# number of lines in terminal
		terminal_width=$(tput cols)												# number of columns in terminal
		terminal_colors=$(tput colors)											# number of colors available

		terminal_save_cursor=$(tput sc)											# save cursor position of terminal
		terminal_restore_cursor=$(tput rc)										# restore cursor position of terminal

		terminal_home_cursor=$(tput home)										# move cursor to upper left corner (0,0) Same as 'tput cup 0 0'
		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})				# move cursor to position (row, column)
		terminal_cursor_down=$(tput cud1)										# move cursor down 1 line
		terminal_cursor_up=$(tput cuu1)											# move cursor up 1 line

		terminal_cursor_hide=$(tput civis)										# set cursor to invisible state
		terminal_cursor_show=$(tput cnorm)										# set cursor to normal state

		terminal_save_screen=$(tput smcup)										# save screen contents
		terminal_restore_screen=$(tput rmcup)									# restore screen contents

		terminal_clear_right=$(tput el)											# clear from cursor to end of line - left
		terminal_clear_left=$(tput el)											# clear from cursor to beginning of line - right
		terminal_clear_down=$(tput ed)											# clear from cursor to end of the screen - down
		terminal_clear_all=$(tput clear)										# clear entire screen and home cursor (0,0) - all
	fi
fi

# markers

marker_top='[ ⋀ ]'
marker_bot='[ ⋁ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ret='[ ⬢ ]'
marker_rel='[ ⬡ ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ ± ]'
marker_msg='[ ¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ • ]'

marker_yes='[ ✓ ]'
marker_not='[ ⨉ ]'

marker_nul='     '

# prompt

console.prompt () {
	# initialize string return array

	console_str=()

	begin="${1}"
	end="${2}"

	[ -z "${count}" ] && count="80"

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	# parse arguments

	[ $# -ge 0 ] && span_character="/"											# 0 argument   - full dash line

	[ $# -eq 1 ] && span_character="/"											# 1 argument   - pad to end of line

	[ $# -eq 3 ] && span_character="${3}"										# 3 arguments  - replace span character with argument 3

	[ $# -ge 2 ] && span=${span::-6}											# 2+ arguments - reduce span by 6 characters: compensate for line marker + space
	[ $# -ge 2 ] && begin="${begin} "											# 2+ arguments - append space to 'begin' value
	[ $# -ge 2 ] && end=" ${end}"												# 2+ arguments - prepend space to 'end' value

	# fold paragraph if character count is above 80
	# indent second line onward (6 spaces) to match line marker

	if [ $# -eq 1 ] && [ "${#begin}" -ge "${count}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${count}" | sed -e '2,$s/^/      /g')
	fi

	# substitute span character

	span="${span//-/$span_character}"

	# print first argument

	span_begin=$(echo -ne "${begin}")

	# print other arguments as fixed width prompt if present

	# calculate span width - remove 6 characters for prompt header

	span_count=$(( ${#span} - ${#begin} - ${#end} ))

	# set new padding width

	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	span_middle="${span}"

	span_end=$(echo -e "${end}")

	# populate array at end to avoid integrating spaces

	[ $# -ge 0 ] && console_str=("${span_begin}""${span_middle}""${span_end}")

	[ $# -eq 1 ] && console_str=("${span_begin}")

	[ $# -ge 2 ] && console_str=("${span_begin}""${span_middle}""${span_end}")

	[ $# -eq 3 ] && console_str=("${span_begin}""${span_middle}""${span_end}")
}

# highlights

console.red () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${red}${value}${reset}"
}

console.green () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${green}${value}${reset}"
}

console.yellow () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${yellow}${value}${reset}"
}

console.blue () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${blue}${value}${reset}"
}

console.magenta () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${value}${reset}"
}

console.cyan () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${value}${reset}"
}

# prompts #

console.maru () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${green}${marker_maru} ${value}${reset}"
}

console.batsu () {
	value="${console_str[@]}"
	console.prompt "$@"

	echo -e "${red}${marker_batsu} ${value}${reset}"
}

console.bako () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_bako} ${value}${reset}"
}

console.sankaku () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${marker_sankaku} ${value}${reset}"
}

console.inf() {
	console.prompt "${@}"
	value="${console_str[@]}"

	echo -e "${blue}${marker_inf} ${value}${reset}"
}

console.msg () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${marker_msg} ${value}${reset}"
}

console.wrn () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${yellow}${marker_wrn} ${value}${reset}"
}

console.add () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${blue}${marker_add} ${value}${reset}"
}

console.rem () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${red}${marker_rem} ${value}${reset}"
}

console.ret () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${cyan}${marker_ret} ${value}${reset}"
}

console.rel () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_rel} ${value}${reset}"
}

console.fwd () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_fwd} ${value}${reset}"
}

console.rev () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_rev} ${value}${reset}"
}

console.stp () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${white}${marker_stp} ${value}${reset}"
}

console.dwl () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"
}

console.upl () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_top} ${value}${reset}"
}

console.lnk () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_stp} ${value}${reset}"
}

console.scs () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"
}

console.err () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"
}

console.ins () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${magenta}${marker_ipt} ${value}${reset}"
}

# prompt inputs

# no new line after prompt: keeps user input beside prompt
# includes space after value to separate input
# use for questions, input, user values

console.ask () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_ask} ${value} ${reset}"
}

console.ipt () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_add} ${value} ${reset}"
}

console.usr () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -ne "${magenta}${marker_usr} ${value} ${reset}"
}

# numbering

# use to mark directives or instructions

console.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${before}${number}${after} ${value}"
}

# prompt separator

# no marker
# use to separate notices and messages from execution blocks

console.sep () {
	console.prompt "$@"
	value="${console_str[@]}"

	echo -e "${value}"
}

# separate

# predefined separator:
# use to separate instructions or warnings from prompts

console.separate () {

	console.sep
	echo
}

# prompt script title

# generic title from script name

console.script () {
	description="${1}"

	console.msg "${description}" "[ ${script%-*} // ${version} ]"
}

# wait

console.wait () {
	# wait in seconds

	seconds="${1}"

	# set defaults

	[ -z "${seconds}" ] && seconds="1"

	sleep "${seconds}"
}

# countdown

console.countdown () {
	before="[ "
	after=" ]"

	seconds="$1"

	shift

	console.prompt "$@"
	value="${console_str[@]}"

	shift

	while [ "${seconds}" -ge 0 ]
	do
		echo -ne "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"

		sleep 1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# progress

console.progress () {
	# catch PID of last command

	PID=$!

	# spinner="\/"

	spinner="⬒◩◧⬕⬓◪◨⬔"
	before="[ "
	after=" ]"

	console.prompt "$@"
	value="${console_str[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -ne "\r${before} \b${spinner:i++%${#spinner}:1}${after} ${value}\c "

		sleep 0.1
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# directory

console.directory () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		directory="${2}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		console.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		[ ! -d "${path}"/"${directory}" ] && mkdir -p "${path}"/"${directory}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# type

console.type () {
	for (( character=0; character<=${#1}; character++ ))
	do
		interval=$(( (RANDOM % 5) + 1 ))
		sleep="0.${interval}"

		printf "%s" "${1:${character}:1}"

		sleep "${sleep}"
	done

	printf '\n'
}

# write

console.write () {
	content="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	for file in ${list[@]}
	do
		console.add "Writing" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" >> "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done
}

# file

console.file () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	for file in ${list[@]}
	do
		console.add "Creating" "[ ${file} ]"
		echo

		# create file and set permissions

		[ ! -f "${path}"/"${file}" ] && touch "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"
	done

	# unset array

	list=()
}

# keep

console.keep () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	cd "${path}" || exit 1

	for item in *
	do
		keep=0

		for file in ${list[@]}
		do
			# mark for keeping

			if [[ "${path}"/"$file" = "${path}"/"$item" ]]
			then
				keep=1

				console.ret "Keeping" "[ ${file} ]"
				echo
			fi
		done

		# remove unmarked items

		[[ "$keep" = 0 ]] && rm -rf "${item}"
	done

	# unset array

	list=()
}

# delete

console.delete () {
	path="${1}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:2})
	else
		file="${2}"

		list=()

		list+=("${file}")
	fi

	for file in ${list[@]}
	do
		console.rem "Deleting" "[ ${file} ]"
		echo

		# remove file

		rm -rf "${path}"/"${file}"
	done

	# unset array

	list=()
}

# copy

console.copy () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${target}" ] && mkdir -p "${target}"

	for file in ${list[@]}
	do
		console.lnk "Copying" "[ ${file} ]"
		echo

		cp -r -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# link

console.link () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${target}" ] && mkdir -p "${target}"

	for file in ${list[@]}
	do
		console.lnk "Linking" "[ ${file} ]"
		echo

		ln -s -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# get

console.get () {
	# parse url and download file according to source concatenation

	command_get () {
		# verify url status

		url_status=$(curl						\
				--write-out "%{http_code}\n"	\
				--silent						\
				--output /dev/null				\
												"${source}"/"${file}"
					)

		if [[ "${url_status}" = [145][0-9][0-9] ]]
		then
			curl -s -L "${source}" > "${path}"/"${file}"

		else
			curl -s -L "${source}"/"${file}" > "${path}"/"${file}"

		fi
	}

	command_get &

	console.progress "Downloading" "[ ${file} ]"
	echo

	chmod a+rx "${path}"/"${file}"
}

# download

console.download () {
	source="${1}"
	path="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${3} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	[ ! -d "${path}" ] && mkdir -p "${path}"

	console.dwl "Loading..."
	echo

	for file in ${list[@]}
	do
		console.get
	done

	# unset array

	list=()
}

# put

console.put () {
	type="${1}"

	curl									\
		-X POST "${destination}/${file}"	\
		-H "Content-Type: ${type}"			\
		-d "${file}" &

	console.progress "Uploading" "[ ${file} ]"
	echo
}

# upload

console.upload () {

	console.upl "Loading..."
	echo

	console.put

}

# silence

console.silence () {
	# wrap command execution and redirect all output to null sink:
	# provides fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> /dev/null 2>&1
}

# log

console.log () {
	# wrap command execution and redirect all output to /var log file:
	# provides logged and fully silent execution

	command="$@"

	"${SHELL}" -c "${command}" >> "${PREFIX}"/var/log/"${script}"-"${stamp}".log 2>&1
}

# password

console.password () {
	# obfuscate password input with custom mask

	mask_character="•"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# input

console.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		console.ipt "${prompt}"

		[[ "${value}" = *password* ]] && console.password || read input

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				console.err "${prompt%:} cannot be empty."
				echo

				prompt="$(echo ${label} | sed 's/_/ /'):"

				console.ipt "${prompt}"

				[[ "${value}" = *password* ]] && console.password || read input
			else
					break
			fi
		done

		value=${label,}

		console_rtn+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean

console.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"

	console.log "${command_autoremove}" &

	console.progress "Flushing packages..."
	echo

	console.log "${command_clean}" &

	console.progress "Cleaning..."
	echo

	# fix dpkg lock and errors:
	# remove all post-install logs - prevent package configuration errors

	[ -d "${PREFIX}"/var/lib/dpkg/info ] && rm -rf "${PREFIX}"/var/lib/dpkg/info/*.postinst
}

# hold

console.hold () {
	export DEBIAN_FRONTEND=noninteractive

	list=($@)

	command_hold="apt-mark hold"

	console.inf "Holding packages."
	echo

	for package in ${list[@]}
	do
		console.wrn "Holding" "[ '${package}' ]"
		echo

		console.log "${command_hold} ${package}" &

		console.progress "Holding..."
		echo
	done

	# unset array

	list=()
}

# release

console.release () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_unhold="apt-mark unhold"

	console.inf "Releasing packages."
	echo

	for package in ${list[@]}
	do
		console.wrn "Releasing" "[ '${package}' ]"
		echo

		console.log "${command_unhold} ${package}" &

		console.progress "Releasing..."
		echo
	done

	# unset array

	list=()
}

# failsafe

console.failsafe () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_update="apt-get update"
	command_upgrade="apt-get upgrade"
	command_install="apt-get install"

	while [[ -z $(command -v "${package}") ]]
	do
		for package in ${list[@]}
		do
		   console.log "yes | ${command_update}"

		   console.log "yes | ${command_upgrade}"

		   console.log "yes | ${command_install}" "${package}"

		   console.log "yes | $command_update"
		done
	done
}

# install

console.install () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_install="apt-get install"

	console.inf "Installing packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -i -o installed)" ]
		then
			console.wrn "Package not installed" "[ '${package}' ]"
			echo

			console.log "yes | ${command_install} ${package}" &

			console.progress "Installing..."
			echo
		else
			console.scs "Package installed" "[ '${package}' ]"
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	console.clean
}

# install

console.install.minimal () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	# use '--no-install-recommends' option to keep bloat to a minimum

	command_install="apt-get install --no-install-recommends --no-upgrade"

	console.inf "Installing minimal package requirements."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -i -o installed)" ]
		then
			console.wrn "Package not installed" "[ '${package}' ]"
			echo

			console.log "yes | ${command_install} ${package}" &

			console.progress "Installing..."
			echo
		else
			console.scs "Package installed" "[ '${package}' ]"
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	console.clean
}

# reinstall

console.reinstall () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_reinstall="apt-get install --reinstall"

	console.inf "Reinstalling packages."
	echo

	for package in ${list[@]}
	do
		console.log "yes | ${command_reinstall} ${package}" &

		console.progress "Reinstalling..."
		echo
	done

	# unset array

	list=()

	# cleanup

	console.clean
}

# update

console.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	console.inf "Processing package and repository information."
	echo

	console.log "${command_update}" &

	console.progress "Updating..."
	echo
}

# upgrade

console.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get upgrade"

	console.inf "Processing installed packages."
	echo

	console.log "yes | ${command_upgrade}" &

	console.progress "Upgrading..."
	echo
}

# purge

console.purge () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_purge="sudo apt-get purge"

	console.inf "Purging selected packages."
	echo

	for package in ${list[@]}
	do
		if [ -z "$(dpkg -s ${package} 2> /dev/null | grep -o installed)" ]
		then
			console.wrn "Selected package" "[ '${package}' ]"
			echo

			console.log "yes | ${command_purge} ${package}" &

			console.progress "Purging..."
			echo
		else
			console.scs "Package not installed" "[ '${package}' ]"
			echo

			console.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	console.clean
}

# dialog

console.dialog () {

	# dialog window title

	title="${script%.sh} - ${1}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${@}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${@}"
	}

	# define dialog usage

	if [[ $(command -v zenity) ]]
	then
		dialog=$(g_dialog)

	elif [[ $(command -v kdialog) ]]
	then
		dialog=$(k_dialog)
	else
		console.wrn "'dialog' not installed."
		console.wrn "This utility must be run using the 'directory' option."
		echo

		console.fwd "Exiting..."
		echo

		exit 1
	fi
}

# clear

console.clear () {
	console.wait

	clear
}

# terminate

console.terminate () {
	process_name="${1}"

	[[ $(command -v pgrep) ]] && process_id=$(pgrep -f "${process_name}")
	[[ $(command -v ps) ]]    && process_id=$(ps -A | grep "${process_name}" | cut -d ' ' -f 1)

	[[ $(command -v kill) ]]  && terminate_command=$(kill -9 ${process_id})
	[[ $(command -v pkill) ]] && terminate_command=$(pkill ${process_name})

	"${terminate_command}"
}

# exit

console.exit () {
	instance="${1}"

	console.countdown 3 "Exiting" "[ ${instance} ]"

	console.kill "${SHELL}"
}

# trap

console.result () {
	checkpoint="${1}"
	instance="${2}"

	if [[ $(command -v "${checkpoint}") ]]
	then
		console.scs "Setup complete" "[ ${instance} ]"
		echo
	else
		console.err "Setup errors were encountered" "[ ${instance} ]"
		echo

		console.inf "Consult setup logs for details" '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

console.trap () {
	instance="${1}"

	[ $# -eq 1 ] && signal="EXIT" || signal="${2}"

	trap "${instance}" "${signal}"
}

console.user () {
	console.inf "Current user name is ${SUDO_USER:-$USER}."

	sleep 1
}
