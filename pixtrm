#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

if [ -f "${HOME}"/.local/bin/frobulator ]
then
	rm -r -f "${HOME}"/.local/bin/frobulator
fi

if [[ -z $(command -v frobulator) ]]
then
	if [[ $(id -u -n) = "root" ]]
	then
		SUDO_HOME=/root

		USER="${SUDO_USER}"

		HOME=/home/"${USER}"
	fi

	if [[ -z $(command -v curl) ]]
	then
		yes | apt-get install curl
	fi

	if [ ! -d "${HOME}"/.local/bin ]
	then
		mkdir -p "${HOME}"/.local/bin
	fi

	if [[ $(id -u -n) = "root" ]]
	then
		chown "${USER}":"${USER}" "${HOME}"/.local/*

		chmod -R 777 "${HOME}"/.local/*
	fi

	curl -s -L get.frbltr.app > "${HOME}"/.local/bin/frobulator

	chmod +x "${HOME}"/.local/bin/frobulator
fi

. "${HOME}"/.local/bin/frobulator

# superuser ////////////////////////////////////////////////////////////////////

export self_arguments="${@}"

# frobulator.escalate

# script ///////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version //////////////////////////////////////////////////////////////////////

version="05-01-2023"

# usage ////////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}"
	in
		-n | --name)
			option="name"
		;;

		-h | --height)
			option="height"

			height="${2}"

			shift
		;;

		-w | --width)
			option="width"

			width="${2}"

			shift
		;;

		-i | --inline)
			option="inline"

		;;

		-s | --stretch)
			option="stretch"
		;;

		-u | --url)
			option="url"
		;;

		-t | --type)
			option="file_type"

			file_type="${2}"

			shift
		;;

		-l | --legacy)
			option="legacy"

			legacy="${2}"

			shift
		;;

		-f | --file)
			option="file"

			file="${2}"

			shift
		;;

		-h | --help)
			echo
			echo -e "Usage: ${script} -n | -h [Height] -w [Width] | -i | -s | -u | -t [File Type] | [-l] | -f [File]"
			echo
			echo -e "Display images using Inline Images Protocol"
			echo
			echo -e "Options:"
			echo
			echo -e "-u, --url        interpret following filename arguments as remote urls"
			echo -e "-f, --file       interpret following filename arguments as local files"
			echo -e "-t, --type       provide a type hint to disambiguate parsing/processing"
			echo -e "-s, --stretch    stretch image to specified width and height"
			echo -e "-w, --width      set image width to n character cells"
			echo -e "-h, --height     set image height to n character cells"
			echo -e "-l, --legacy     use legacy protocol - transfers image as a single monolithic control sequence"
			echo
			echo -e "-h, --help       show help and usage information."
			echo
			echo -e "If width or height are not specified, an appropriate value will be chosen automatically."
			echo -e "Width and height are given as 'auto' or numeric digit n, defined as the number of terminal character cells."
			echo
			echo -e "    n      character cells"
			echo -e "    npx    pixels"
			echo -e "    n%     percent of the session's width or height"
			echo
			echo -e "    auto   the imagesize will be used to determine the appropriate dimension dimension"
			echo
			echo -e "The file type can be a mime type (i.e.: text/markdown), a language name (i.e: Java), or a file extension i.e.: (.sh)"
			echo -e "The file type can usually be inferred from the extension or its contents."
			echo -e "The type option is most useful when a filename is not available, such as whe input comes from a pipe."
			echo
			echo -e "Usage examples:"
			echo
			echo -e "    ${script} -w 250px -h 250px -s image.png"
			echo
			echo -e "    cat image.png | ${script} -w 75%"
			echo
			echo -e "    ${script} -p -w 500px -u http://host.url/path/to/image.gif -w 80 -f image.png"
			echo
			echo -e "    cat url-list.txt | xargs ${script} -p -w 40 -u"
			echo
			echo -e "    ${script} -t application/json config.json"
			echo

			exit
		;;

		*)
			echo
			echo -e "Usage: ${script} -n | -h [Height] -w [Width] | -i | -s | -u | -t [File Type] | [-l] | -f [File]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1
		;;

	esac

	shift

done

# functions ////////////////////////////////////////////////////////////////////

# set -o pipefail

image_osc () {

	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\033Ptmux;\033\033]"
	else
		printf "\033]"
	fi
}

image_st () {

	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\a\033\\"
	else
		printf "\a"
	fi
}

image_unit () {

	unit="${1}"

	# verify image sizing unit format:
	# [n] / [n]px / [n]% / auto

	if [[ ! "$1" =~ ^(:?[0-9]+(:?px|%)?|auto)$ ]]
	then
		frobulator.err "Invalid image sizing unit" "[ '${unit}' ]"
		echo

		exit 1
	fi
}

image_parse () {

	# image_parse image inline encoding name width height ratio file_type legacy

	# $1 image:       filename to convey to client
	# $2 inline:      0 or 1, if set to 1, the file will be displayed inline, otherwise, it will be downloaded
	# $3 encoding:    base64-encoded contents
	# $4 name:        0 or 1, if set to 1, print the filename name after image output
	# $5 width:       set output width of the image in character cells, pixels or percent
	# $6 height:      set output height of the image in character cells, pixels or percent
	# $7 ratio:       0 or 1, if set to 1, fill the specified width and height as much as possible without stretching the image
	# $8 file:        empty string or file type like "application/json" or ".js".
	# $9 legacy:      1 - send one monolithic control sequence
	#                 0 - send many small control sequencess

	echo

	# send metadata to begin transfer

	image_osc

	printf "1337;"

	if [[ "${9}" -eq 1 ]]
	then
		printf "File"
	else
		printf "MultipartFile"
	fi

	printf "=inline=%s" "${2}"

	printf ";size=%d" $(printf "%s" "${3}" | base64 -d -i | wc -c)

	if [ -n "${1}" ]
	then
		printf ";name=%s" "$(printf "%s" "${1}" | base64 -w 0)"
	fi

	if [ -n "${5}" ]
	then
		printf ";width=%s" "${5}"
	fi

	if [ -n "${6}" ]
	then
		printf ";height=%s" "${6}"
	fi

	if [ -n "${7}" ]
	then
		printf ";preserveAspectRatio=%s" "${7}"
	fi

	[ -n "${8}" ] && printf ";type=%s" "${8}"

	if [[ "${9}" -eq 1 ]]
	then
		printf ":%s" "${3}"

		image_st
	else
		image_st

		# split into 200-byte chunks:
		# helps parsing through 'tmux'

		parts=$(printf "%s" "${3}" | fold -w 200)

		# load byte stream

		for part in "${parts}"
		do
			image_osc

			printf '1337;FilePart=%s' "${part}"

			image_st
		done

		# indicate completion

		image_osc

		printf '1337;FileEnd'

		image_st
	fi

	echo

	if [ "${4}" == "1" ]
	then
		echo "${1}"
	fi
}

image_print () {

	if [ "${stdin}" = "stdin" ]
	then
		image=""
		inline="1"
		encoding=$(cat | base64 -w 0)

	elif [ "${stdin}" = "tty" ]
	then
		inline="1"
	fi

	image_parse "${image}" "${inline}" "${encoding}" ${name} "${width}" "${height}" "${ratio}" "${file_type}" "${legacy}"

}

# options //////////////////////////////////////////////////////////////////////

if [ -t 0 ]
then
	# 'stdin' is a tty

	stdin="tty"
else
	stdin="stdin"
fi

if [[ "${option}" = "inline" ]]
then
	inline="1"
else
	inline="0"
fi

if [[ "${option}" = "name" ]]
then
	name="1"
else
	name="0"
fi

if [[ "${option}" = "stretch" ]]
then
	ratio="0"
else
	ratio="1"
fi

if [[ "${option}" = "file" ]]
then
	stdin="tty"

	url="false"

elif [[ "${option}" = "url" ]]
then
	stdin="tty"

	url="true"

fi

if [[ "${option}" = "legacy" ]]
then
	legacy="1"
fi

# defaults /////////////////////////////////////////////////////////////////////

stdin="${stdin}"

image="${file}"

inline="1"

file_type=""

legacy="1"

url="false"

# variables ////////////////////////////////////////////////////////////////////

if [ -z "${image}" ]
then
	frobulator.err "No image supplied"
	echo

	exit 1
fi

if [ "${url}" = "true" ]
then
	encoding=$(curl -s -L "${image}" | base64 -w 0)

	if [ ${?} -ne 0 ]
	then
		frobulator.err "Could not retrieve image from URL ${image}, error_code: ${?}"
		echo

		exit 2
	fi
fi

if [ "${url}" = "false" ]
then
	if [ -r "${image}" ]
	then
		encoding=$(cat "${image}" | base64 -w 0)
	else
		frobulator.err "${script}: ${image}: No such file or directory"
		echo

		exit 2
	fi
fi

if [ -n "${height}" ]
then
	image_unit "${height}"
fi

if [ -n "${width}" ]
then
	image_unit "${width}"
fi

image_print
