#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

if [ -f "${HOME}"/.local/bin/frobulator ]
then
	rm -r -f "${HOME}"/.local/bin/frobulator
fi

if [[ -z $(command -v frobulator) ]]
then
	if [[ $(id -u -n) = "root" ]]
	then
		SUDO_HOME=/root

		USER="${SUDO_USER}"

		HOME=/home/"${USER}"
	fi

	if [[ -z $(command -v curl) ]]
	then
		yes | apt-get install curl
	fi

	if [ ! -d "${HOME}"/.local/bin ]
	then
		mkdir -p "${HOME}"/.local/bin
	fi

	if [[ $(id -u -n) = "root" ]]
	then
		chown "${USER}":"${USER}" "${HOME}"/.local/*

		chmod -R 777 "${HOME}"/.local/*
	fi

	curl -s -L get.frbltr.app > "${HOME}"/.local/bin/frobulator

	chmod +x "${HOME}"/.local/bin/frobulator
fi

. "${HOME}"/.local/bin/frobulator

# superuser ////////////////////////////////////////////////////////////////////

export self_arguments="${@}"

# frobulator.escalate

# script ///////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version //////////////////////////////////////////////////////////////////////

version="05-01-2023"

# usage ////////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}"
	in
		-i | --inline)
			option="inline"
		;;
		
		-n | --name)
			option="name"
		;;

		-h | --height)
			option="height"

			height="${2}"

			shift
		;;

		-w | --width)
			option="width"

			width="${2}"

			shift
		;;

		-s | --stretch)
			option="stretch"
		;;

		-f | --file)
			option="file"

			file="${2}"

			shift
		;;
		
		-u | --url)
			option="url"
		;;

		-t | --type)
			option="file_type"

			file_type="${2}"

			shift
		;;

		-l | --legacy)
			option="legacy"

			legacy="${2}"

			shift
		;;

		-h | --help)
			echo
			echo -e "Usage: ${script} -i | -n | -h [Height] -w [Width] | -s | -f [File] | -u | -t [File Type] | [-l]"
			echo
			echo -e "Display images using base64-encoded inline image display protocol"
			echo
			echo -e "Options:"
			echo
			echo -e "-i, --inline     display image inline"
			echo -e "-n, --name       display filename after parsing image"
			echo
			echo -e "-h, --height     set image height to n character cells"
			echo -e "-w, --width      set image width to n character cells"
			echo -e "-s, --stretch    stretch image to specified width and height"
			echo
			echo -e "-f, --file       interpret following filename arguments as local files"
			echo -e "-u, --url        interpret following filename arguments as remote urls"
			echo
			echo -e "-t, --type       provide a type hint to disambiguate parsing/processing"
			echo -e "-l, --legacy     use legacy protocol - transfers image as a single monolithic control sequence"
			echo
			echo -e "-h, --help       show help and usage information."
			echo
			echo -e "Image sizing:"
			echo
			echo -e "    If width or height are not specified, an appropriate value will be chosen automatically."
			echo -e "    Width and height are given as 'auto' or numeric digit n, defined as the number of terminal character cells."
			echo
			echo -e "    n      character cells"
			echo -e "    npx    pixels"
			echo -e "    n%     percent of the session's width or height"
			echo
			echo -e "    auto   the imagesize will be used to determine the appropriate dimension dimension"
			echo
			echo -e "File type:"
			echo
			echo -e "    The file type can be a mime type (i.e.: text/markdown), a language name (i.e: Java), or a file extension i.e.: (.sh)"
			echo -e "    The file type can usually be inferred from the extension or its contents."
			echo -e "    The type option is most useful when a filename is not available, such as whe input comes from a pipe."
			echo
			echo -e "Usage examples:"
			echo
			echo -e "    ${script} -w 250px -h 250px -s image.png"
			echo
			echo -e "    cat image-01.png | ${script} -w 75%"
			echo -e "    cat image-02.jpg | ${script} -h 30%"
			echo
			echo -e "    ${script} -n -w 500px -u http://host.url/path/to/image.gif -w 80 -f image.png"
			echo
			echo -e "    cat url-list[.txt] | xargs ${script} -n -w 40 -u"
			echo
			echo -e "    ${script} -t application/json config.json"
			echo

			exit
		;;

		*)
			echo
			echo -e "Usage: ${script} -i | -n | -h [Height] -w [Width] | -s | -f [File] | -u | -t [File Type] | [-l]"
			echo
			echo -e "${script}: Unknown option '${1}'"
			echo -e "Type './${script} --help' for help and usage information."
			echo

			exit 1
		;;

	esac

	shift

done

# functions ////////////////////////////////////////////////////////////////////

# set -o pipefail

image_osc () {

	# osc - opening sequence characters
	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\033Ptmux;\033\033]"
	else
		printf "\033]"
	fi
}

image_tsc () {

	# tsc - termination secquence characters
	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\a\033\\"
	else
		printf "\a"
	fi
}

image_unit () {

	unit="${1}"

	# verify image sizing unit format:
	# [n] / [n]px / [n]% / auto

	if [[ ! "$1" =~ ^(:?[0-9]+(:?px|%)?|auto)$ ]]
	then
		frobulator.err "Invalid image sizing unit" "[ '${unit}' ]"
		echo

		exit 1
	fi
}

image_parse () {

	# image_parse image inline encoding name width height ratio file_type legacy

	# ${1} image:       image filename

	# ${2} inline:      0 - download image
	#                   1 - display inline
	# ${3} encoding:    base64-encoded image contents

	# ${4} name:        0 - no filename display after image processing
	#                   1 - display filename after image processing

	# ${5} width:       set image output width - numeric digits only
	#                   n    - character cells
	#                   npx  - pixels
	#                   n%   - percentage (width only or height only)
	#                   auto - automatic calculation to terminal output

	# ${6} height:      set image output height - numeric digits only
	#                   n    - character cells
	#                   npx  - pixels
	#                   n%   - percentage (width only or height only)
	#                   auto - automatic calculation to terminal output

	# ${7} ratio:       0 - fill specified height or width value to maximum terminal output
	#                   1 - fill specified height or width value to maximum terminal output without deformation

	# ${8} file:        file type hint
	#                   "" - empty value [Default]
	#                   mimetype  - ex.: application/json
	#					name      - ex.: Python
	#					extension - ex.: .sh

	# ${9} legacy:      1 - parse and send as one monolithic control sequence
	#                   0 - parse and send as multiple 200-byte control sequences

	echo

	# open sequence - begin transfer

	image_osc

	printf "1337;"

	if [[ "${9}" -eq 1 ]]
	then
		printf "File"
	else
		printf "MultipartFile"
	fi

	printf "=inline=%s" "${2}"

	printf ";size=%d" $(printf "%s" "${3}" | base64 -d -i | wc -c)

	if [ -n "${1}" ]
	then
		printf ";name=%s" "$(printf "%s" "${1}" | base64 -w 0)"
	fi

	if [ -n "${5}" ]
	then
		printf ";width=%s" "${5}"
	fi

	if [ -n "${6}" ]
	then
		printf ";height=%s" "${6}"
	fi

	if [ -n "${7}" ]
	then
		printf ";preserveAspectRatio=%s" "${7}"
	fi

	[ -n "${8}" ] && printf ";type=%s" "${8}"

	if [[ "${9}" -eq 1 ]]
	then
		printf ":%s" "${3}"

		image_tsc
	else
		image_tsc

		# split into 200-byte parts:
		# optimizes parsing through terminal multiplexer

		bytes=200

		split=$(fold -w ${bytes})

		parts=$(printf "%s" "${3}" | ${split})

		# load byte stream

		for part in "${parts}"
		do
			image_osc

			printf '1337;FilePart=%s' "${part}"

			image_tsc
		done

		# terminate sequence

		image_osc

		printf '1337;FileEnd'

		image_tsc
	fi

	echo

	if [ "${4}" == "1" ]
	then
		echo "${1}"
	fi
}

image_print () {

	if [ "${stdin}" = "stdin" ]
	then
		image=""
		inline="1"
		encoding=$(cat | base64 -w 0)

	elif [ "${stdin}" = "tty" ]
	then
		inline="1"
	fi

	image_parse "${image}" "${inline}" "${encoding}" "${name}" "${width}" "${height}" "${ratio}" "${file_type}" "${legacy}"

}

# options //////////////////////////////////////////////////////////////////////

if [ -t 0 ]
then
	# 'stdin' is a tty

	stdin="tty"
else
	stdin="stdin"
fi

if [[ "${option}" = "inline" ]]
then
	inline="1"
else
	inline="0"
fi

if [[ "${option}" = "name" ]]
then
	name="1"
else
	name="0"
fi

if [[ "${option}" = "stretch" ]]
then
	ratio="0"
else
	ratio="1"
fi

if [[ "${option}" = "file" ]]
then
	stdin="tty"

	url="false"

elif [[ "${option}" = "url" ]]
then
	stdin="tty"

	url="true"

fi

if [[ "${option}" = "legacy" ]]
then
	legacy="1"
fi

# defaults /////////////////////////////////////////////////////////////////////

stdin="${stdin}"

image="${file}"

inline="1"

file_type=""

legacy="1"

url="false"

name="0"

# variables ////////////////////////////////////////////////////////////////////

if [ -z "${image}" ]
then
	frobulator.err "No image supplied"
	echo

	exit 1
fi

if [ "${url}" = "true" ]
then
	encoding=$(curl -s -L "${image}" | base64 -w 0)

	if [ ${?} -ne 0 ]
	then
		frobulator.err "Could not retrieve image from URL ${image}, error_code: ${?}"
		echo

		exit 2
	fi
fi

if [ "${url}" = "false" ]
then
	if [ -r "${image}" ]
	then
		encoding=$(cat "${image}" | base64 -w 0)
	else
		frobulator.err "${script}: ${image}: No such file or directory"
		echo

		exit 2
	fi
fi

if [ -n "${height}" ]
then
	image_unit "${height}"
fi

if [ -n "${width}" ]
then
	image_unit "${width}"
fi

image_print
