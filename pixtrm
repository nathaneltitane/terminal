#!/usr/bin/env bash

set -o pipefail

image_osc () {

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\033Ptmux;\033\033]"
	else
		printf "\033]"
	fi
}

image_st () {

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\a\033\\"
	else
		printf "\a"
	fi
}

codec_validate () {

	codec="base64"

	if [ -z "${codec_version+x}" ]
	then
		codec_version=$(${codec} --version 2>&1)

		export codec

		export codec_version
	fi
}

image_encode () {

	codec_validate

	if [[ "${codec_version}" =~ GNU ]]
	then
		# disable line wrap

		"${codec}" -w0
	else
		"${codec}"
	fi
}

image_decode () {

	codec_validate

	if [[ "${codec_version}" =~ fourmilab ]]
	then
		codec_argument=-d

	elif [[ "${codec_version}" =~ GNU ]]
	then
		codec_argument=-di
	else
		codec_argument=-D
	fi

	"${codec}" "${codec_argument}"
}

image_missing () {

	if [ "${image_display}" != "true" ]
	then
		echo "No image provided. Check command line options."

		exit 1
	fi
}

image_print () {

	if [ "${stdin_present}" = "true" ]
	then
		image_parse "" 1 "$(cat | image_encode)" 0 "${width}" "${height}" "${preserve_aspect_ratio}" "${file_type}" "${legacy}"
	fi

}

image_parse () {

	# image_parse filename inline base64contents print_filename width height preserve_aspect_ratio
	#  $1 filename: Filename to convey to client
	#  $2 inline: 0 or 1, if set to 1, the file will be displayed inline, otherwise, it will be downloaded
	#  $3 base64contents: Base64-encoded contents
	#  $4  print_filename: 0 or 1, if set to 1, print the filename after outputting the image
	#  $5 width: set output width of the image in character cells, pixels or percent
	#  $6 height: set output height of the image in character cells, pixels or percent
	#  $7 preserve_aspect_ratio: 0 or 1, if set to 1, fill the specified width and height as much as possible without stretching the image
	#  $8 file: Empty string or file type like "application/json" or ".js".
	#  $9 legacy: 1 to send one giant control sequence, 0 to send many small control sequences.

	printf '\n'

	# Send metadata to begin transfer.

	image_osc

	printf "1337;"

	if [[ "${9}" -eq 1 ]]
	then
		printf "File"
	else
		printf "MultipartFile"
	fi

	printf "=inline=%s" "${2}"

	printf ";size=%d" $(printf "%s" "${3}" | image_decode | wc -c)

	if [ -n "${1}" ]
	then
		printf ";name=%s" "$(printf "%s" "${1}" | image_encode)"
	fi

	if [ -n "${5}" ]
	then
		printf ";width=%s" "${5}"
	fi

	if [ -n "${6}" ]
	then
		printf ";height=%s" "${6}"
	fi

	if [ -n "${7}" ]
	then
		printf ";preserveAspectRatio=%s" "${7}"
	fi

	[ -n "${8}" ] && printf ";type=%s" "${8}"

	if [[ "${9}" -eq 1 ]]
	then
		printf ":%s" "${3}"

		image_st
	else
		image_st

		# split into 200-byte chunks:
		# helps parsing through 'tmux'

		stream=200
		bytes=$(fold -w ${stream})
		parts=$(printf "%s" "${3}" | ${bytes})

		# load byte stream

		for part in ${parts}
		do
			image_osc

			printf '1337;FilePart=%s' "${part}"

			image_st
		done

		# Indicate completion

		image_osc

		printf '1337;FileEnd'

		image_st
	fi

	printf '\n'

	[ "${4}" == "1" ] && echo "${1}"

	image_display="true"
}

image_unit () {

	# verify image sizing unit format:
	# N / Npx / N% / auto

	if [[ ! "${1}" =~ ^(:?[0-9]+(:?px|%)?|auto)$ ]]
	then
		error "Invalid image sizing unit - '${1}'"
		show_help
		exit 1
	fi
}

# check stdin presence

if [ -t 0 ]
then
	stdin_present="false"
else
	stdin_present="true"
fi

# Show help if no arguments and no stdin.

if [ "${stdin_present}" = "false" ] && [ $# -eq 0 ]
then
	show_help
	exit
fi

file_type=""

legacy=0

# usage

while [ $# -gt 0 ]
do
	case "${1}"
	in
		-h | --h | --help)
			errcho
			errcho "Usage: ${0} [-p] [-n] [-W width] [-H height] [-r] [-s] [-u] [-t file-type] [-f] filename ..."
			errcho "       cat filename | ${0} [-W width] [-H height] [-r] [-s]"
			errcho
			errcho "Display images inline in the iTerm2 using Inline Images Protocol"
			errcho
			errcho "Options:"
			errcho
			errcho "    -h, --help                      Display help message"
			errcho "    -p, --print                     Enable printing of filename or URL after each image"
			errcho "    -n, --no-print                  Disable printing of filename or URL after each image"
			errcho "    -u, --url                       Interpret following filename arguments as remote URLs"
			errcho "    -f, --file                      Interpret following filename arguments as regular Files"
			errcho "    -t, --type file-type            Provides a type hint"
			errcho "    -r, --preserve-aspect-ratio     When scaling image preserve its original aspect ratio"
			errcho "    -s, --stretch                   Stretch image to specified width and height (this option is opposite to -r)"
			errcho "    -W, --width N                   Set image width to N character cells, pixels or percent (see below)"
			errcho "    -H, --height N                  Set image height to N character cells, pixels or percent (see below)"
			errcho "    -l, --legacy                    Use legacy protocol that sends the whole image in a single control sequence"
			errcho
			errcho "    If you don't specify width or height an appropriate value will be chosen automatically."
			errcho "    The width and height are given as word 'auto' or number N followed by a unit:"
			errcho "        N      character cells"
			errcho "        Npx    pixels"
			errcho "        N%     percent of the session's width or height"
			errcho "        auto   the image's inherent size will be used to deTERMine an appropriate dimension"
			errcho
			errcho "    If a type is provided, it is used as a hint to disambiguate."
			errcho "    The file type can be a mime type like text/markdown, a language name like Java, or a file extension like .c"
			errcho "    The file type can usually be inferred from the extension or its contents. -t is most useful when"
			errcho "    a filename is not available, such as whe input comes from a pipe."
			errcho
			errcho "Examples:"
			errcho
			errcho "    $ ${0} -W 250px -H 250px -s avatar.png"
			errcho "    $ cat graph.png | ${0} -W 100%"
			errcho "    $ ${0} -p -W 500px -u http://host.tld/path/to/image.jpg -W 80 -f image.png"
			errcho "    $ cat url_list.txt | xargs ${0} -p -W 40 -u"
			errcho "    $ ${0} -t application/json config.json"
			errcho
		;;

		-p | --print)
			print_filename=1
		;;

		-n | --no-print)
			print_filename=0
		;;

		-W | --width)
			image_unit "${2}"

			width="${2}"

			shift
		;;

		-H | --height)
			image_unit "${2}"

			height="${2}"

			shift
		;;

		-r | --preserve-aspect-ratio)
			preserve_aspect_ratio=1
		;;

		-s | --stretch)
			preserve_aspect_ratio=0
		;;

		-l | --legacy)
			legacy=1
		;;

		-f | --file)
			stdin_present=f
			is_url="false"
		;;

		-u | --url)
			stdin_present="false"
			is_url="true"
		;;

		-t | --type)
			file_type="${2}"

			shift
		;;

		-*)
			error "Unknown option flag: ${1}"

			exit 1
		;;

		*)
			if [ "${is_url}" == "true" ]
			then
				encoded_image=$(curl -s -L  "${1}" | image_encode) || {
				echo "Could not retrieve image from URL ${1}, error_code: $?"
				exit 2
			}
			elif [ -r "${1}" ]
			then
				encoded_image=$(cat "${1}" | image_encode)
			else
				echo "${0}: ${1}: No such file or directory"
				exit 2
			fi

			stdin_present="false"

			image_parse "${1}" 1 "${encoded_image}" "${print_filename}" "${width}" "${height}" "${preserve_aspect_ratio}" "${file_type}" "${legacy}"
		;;

		esac

	shift

done

# read and print stdin

image_print

image_missing
