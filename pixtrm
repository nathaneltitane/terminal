#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

if [ -f "${HOME}"/.local/bin/frobulator ]
then
	rm -r -f "${HOME}"/.local/bin/frobulator
fi

if [[ -z $(command -v frobulator) ]]
then
	if [[ $(id -u -n) = "root" ]]
	then
		SUDO_HOME=/root

		USER="${SUDO_USER}"

		HOME=/home/"${USER}"
	fi

	if [[ -z $(command -v curl) ]]
	then
		yes | apt-get install curl
	fi

	if [ ! -d "${HOME}"/.local/bin ]
	then
		mkdir -p "${HOME}"/.local/bin
	fi

	if [[ $(id -u -n) = "root" ]]
	then
		chown "${USER}":"${USER}" "${HOME}"/.local/*

		chmod -R 777 "${HOME}"/.local/*
	fi

	curl -s -L get.frbltr.app > "${HOME}"/.local/bin/frobulator

	chmod +x "${HOME}"/.local/bin/frobulator
fi

. "${HOME}"/.local/bin/frobulator

# superuser ////////////////////////////////////////////////////////////////////

export self_arguments="${@}"

# frobulator.escalate

# script ///////////////////////////////////////////////////////////////////////

script=$(basename -- "${BASH_SOURCE[0]}")

# version //////////////////////////////////////////////////////////////////////

version="05-01-2023"

# usage ////////////////////////////////////////////////////////////////////////

while (($#))
do
	case "${1}"
	in
		-p | --print)
			option="print_filename"
		;;

		-n | --no-print)
			option="no_print_filename"
		;;

		-H | --height)
			option="height"

			height="${2}"

			shift
		;;

		-W | --width)
			option="width"

			width="${2}"

			shift
		;;

		-i | --inline)
			option="inline"

		;;

		-r | --preserve-aspect-ratio)
			option="preserve_aspect_ratio"
		;;

		-s | --stretch)
			option="stretch"
		;;


		-f | --file)
			option="file"

			file="${2}"

			shift
		;;

		-u | --url)
			option="url"
		;;

		-t | --type)
			option="file_type"

			file_type="${2}"

			shift
		;;

		-l | --legacy)
			option="legacy"

			legacy="${2}"

			shift
		;;

		-h | --help)
			echo
			echo -e "Usage: ${script} [-p] [-n] [-W width] [-H height] [-r] [-s] [-u] [-t file-type] [-f] filename [-l]"
			echo -e "       cat filename | ${script} [-W width] [-H height] [-r] [-s]"
			echo
			echo -e "Display images inline in the iTerm2 using Inline Images Protocol"
			echo
			echo -e "Options:"
			echo
			echo -e "-h, --help                      Display help message"
			echo -e "-p, --print                     Enable printing of filename or URL after each image"
			echo -e "-n, --no-print                  Disable printing of filename or URL after each image"
			echo -e "-u, --url                       Interpret following filename arguments as remote URLs"
			echo -e "-f, --file                      Interpret following filename arguments as regular Files"
			echo -e "-t, --type file-type            Provides a type hint"
			echo -e "-r, --preserve-aspect-ratio     When scaling image preserve its original aspect ratio"
			echo -e "-s, --stretch                   Stretch image to specified width and height (this option is opposite to -r)"
			echo -e "-W, --width N                   Set image width to N character cells, pixels or percent (see below)"
			echo -e "-H, --height N                  Set image height to N character cells, pixels or percent (see below)"
			echo -e "-l, --legacy                    Use legacy protocol that sends the whole image in a single control sequence"
			echo
			echo -e "If you don't specify width or height an appropriate value will be chosen automatically."
			echo -e "The width and height are given as word 'auto' or number N followed by a unit:"
			echo
			echo -e "    N      character cells"
			echo -e "    Npx    pixels"
			echo -e "    N%     percent of the session's width or height"
			echo -e "    auto   the image's inherent size will be used to deTERMine an appropriate dimension"
			echo
			echo -e "If a type is provided, it is used as a hint to disambiguate."
			echo -e "The file type can be a mime type like text/markdown, a language name like Java, or a file extension like .c"
			echo -e "The file type can usually be inferred from the extension or its contents. -t is most useful when"
			echo -e "a filename is not available, such as whe input comes from a pipe."
			echo
			echo -e "Examples:"
			echo
			echo -e "${script} -W 250px -H 250px -s avatar.png"
			echo -e "cat graph.png | ${script} -W 100%"
			echo -e "${script} -p -W 500px -u http://host.tld/path/to/image.jpg -W 80 -f image.png"
			echo -e "cat url_list.txt | xargs ${script} -p -W 40 -u"
			echo -e "${script} -t application/json config.json"
			echo

			exit
		;;

		-*)
			frobulator.err "Unknown option flag: ${1}"
			echo

			frobulator.stp "Aborting${marker_elp}"
			echo

			exit 1
		;;


	esac

	shift

done

# functions ////////////////////////////////////////////////////////////////////

# set -o pipefail

standard_input () {

	# check for standard input presence

	if [ -t 0 ]
	then
		# 'stdin' is a tty

		stdin_present="false"
	else
		stdin_present="true"
	fi

	if [ "${stdin_present}" = "false" ] && [ $# -eq 0 ]
	then
		frobulator.err "No 'stdin' present or arguments passed."
		echo

		exit 1
	fi
}

image_osc () {

	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\033Ptmux;\033\033]"
	else
		printf "\033]"
	fi
}

image_st () {

	# verify terminal multiplexer instance and type

	if [[ "${TERM}" == screen* || "${TERM}" == tmux* ]]
	then
		printf "\a\033\\"
	else
		printf "\a"
	fi
}

image_unit () {

	unit="${1}"

	# verify image sizing unit format:
	# N / Npx / N% / auto

	if [[ ! "${unit}" =~ ^(:?[0-9]+(:?px|%)?|auto)$ ]]
	then
		frobulator.err "Invalid image sizing unit - '${unit}'"
		echo

		exit 1
	fi
}

image_missing () {

	if [ "${image_display}" != "true" ]
	then
		frobulator.err "No image provided. Check command line options."
		echo

		exit 1
	fi
}

image_parse () {

	# image_parse filename inline encoding print_filename width height preserve_aspect_ratio file_type legacy

	# $1 filename:                 filename to convey to client
	# $2 inline:                   0 or 1, if set to 1, the file will be displayed inline, otherwise, it will be downloaded
	# $3 encoding:                 base64-encoded contents
	# $4 print_filename:          0 or 1, if set to 1, print the filename after outputting the image
	# $5 width:                    set output width of the image in character cells, pixels or percent
	# $6 height:                   set output height of the image in character cells, pixels or percent
	# $7 preserve_aspect_ratio:    0 or 1, if set to 1, fill the specified width and height as much as possible without stretching the image
	# $8 file:                     empty string or file type like "application/json" or ".js".
	# $9 legacy:                   1 - send one monolithic control sequence
	#                              0 - send many small control sequencess

	echo

	# send metadata to begin transfer

	image_osc

	printf "1337;"

	if [[ "${9}" -eq 1 ]]
	then
		printf "File"
	else
		printf "MultipartFile"
	fi

	printf "=inline=%s" "${2}"

	printf ";size=%d" $(printf "%s" "${3}" | base64 -d -i | wc -c)

	if [ -n "${1}" ]
	then
		printf ";name=%s" "$(printf "%s" "${1}" | base64 -w 0)"
	fi

	if [ -n "${5}" ]
	then
		printf ";width=%s" "${5}"
	fi

	if [ -n "${6}" ]
	then
		printf ";height=%s" "${6}"
	fi

	if [ -n "${7}" ]
	then
		printf ";preserveAspectRatio=%s" "${7}"
	fi

	[ -n "${8}" ] && printf ";type=%s" "${8}"

	if [[ "${9}" -eq 1 ]]
	then
		printf ":%s" "${3}"

		image_st
	else
		image_st

		# split into 200-byte chunks:
		# helps parsing through 'tmux'

		parts=$(printf "%s" "${3}" | fold -w 200)

		# load byte stream

		for part in "${parts}"
		do
			image_osc

			printf '1337;FilePart=%s' "${part}"

			image_st
		done

		# indicate completion

		image_osc

		printf '1337;FileEnd'

		image_st
	fi

	echo

	if [ "${4}" == "1" ]
	then
		echo "${1}"
	fi

	image_display="true"
}

image_print () {

	if [ "${stdin_present}" = "true" ]
	then
		image=""
		inline="1"
		encoding=$(cat | base64 -w 0)

	elif [ "${stdin_present}" = "false" ]
	then
		inline="1"
	fi

	image_parse "${image}" "${inline}" "${encoding}" ${print_filename} "${width}" "${height}" "${preserve_aspect_ratio}" "${file_type}" "${legacy}"

}

# options //////////////////////////////////////////////////////////////////////

if [[ "${option}" = "inline" ]]
then
	inline="1"
else
	inline="0"
fi

if [[ "${option}" = "print_filename" ]]
then
	print_filename="1"

elif [[ "${option}" = "no_print_filename" ]]
then
	print_filename="0"
fi

if [[ "${option}" = "height" ]] || \
   [[ "${option}" = "width"  ]]
then
	image_unit "${2}"
fi

if [[ "${option}" = "preserve_aspect_ratio" ]]
then
	preserve_aspect_ratio="1"

elif [[ "${option}" = "stretch" ]]
then
	preserve_aspect_ratio=0
fi


if [[ "${option}" = "file" ]]
then
	stdin_present="false"

	is_url="false"

elif [[ "${option}" = "url" ]]
then
	stdin_present="false"

	is_url="true"

fi

if [[ "${option}" = "legacy" ]]
then
	legacy="1"
fi

# defaults /////////////////////////////////////////////////////////////////////

stdin_present="false"

image="${file}"

inline="1"

print_filename="0"

preserve_aspect_ratio="1"

file_type=""

legacy="1"

is_url="false"

image_display="false"

# variables ////////////////////////////////////////////////////////////////////

if [ "${is_url}" == "true" ]
then
	encoding=$(curl -s -L "${image}" | base64 -w 0)

	if [ ${?} -ne 0 ]
	then
		frobulator.err "Could not retrieve image from URL ${image}, error_code: ${?}"
		echo

		exit 2
	fi
else
	if [ -r "${image}" ]
	then
		encoding=$(cat "${image}" | base64 -w 0)
	else
		frobulator.err "${script}: ${image}: No such file or directory"
		echo

		exit 2
	fi
fi


image_print

